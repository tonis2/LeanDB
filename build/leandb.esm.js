class e{constructor(e,t,s){return this.createTransaction(e,t,s)}async createTransaction(e,t,s){const a=await e,r=await a.transaction(t,s);return await r}}class t{constructor(e,t,s){this.name=e,this.version=t,this.db=s}async add(t){return new Promise(async(s,a)=>{const r=await new e(this.db,this.name,"readwrite");let n=await r.objectStore(this.name).put(t);n.onerror=(e=>{a(e.target.error.message)}),n.onsuccess=(e=>{s(e.target.result)})})}delete(t){return new Promise(async s=>{const a=await new e(this.db,this.name,"readwrite");(await a.objectStore(this.name).openCursor()).onsuccess=(e=>{const a=e.target.result;if(a){Object.keys(t).map(e=>Object.is(a.value[e],t[e])).filter(e=>!e).length<1&&a.delete(),a.continue()}else s()})})}update(t){return this.value=(s=>new Promise(async a=>{const r=await new e(this.db,this.name,"readwrite");(await r.objectStore(this.name)).openCursor().onsuccess=(e=>{const r=e.target.result;if(r){Object.keys(t).map(e=>Object.is(r.value[e],t[e])).filter(e=>!e).length<1&&(r.update(Object.assign(r.value,s)),a(r.value)),r.continue()}else a(r)})})),this}async find(t){return new Promise(async(s,a)=>{const r=await new e(this.db,this.name,"readwrite"),n=(await r.objectStore(this.name)).openCursor(),i=[];n.onsuccess=(e=>{const a=e.target.result;if(a){Object.keys(t).map(e=>Object.is(a.value[e],t[e])).filter(e=>!e).length<1&&i.push(a.value),a.continue()}else s(i)}),n.onerror=(e=>{a(`Failed to apply search in ${this.name}`)})})}}class s{constructor(e,t,s){return this.name=e,this.version=t,this.start_database(s)}start_database(e){const t=indexedDB.open(this.name,this.version||1);return new Promise((s,a)=>{t.onsuccess=(e=>s(e.target.result)),t.onerror=(e=>a(e.target.result)),e&&(t.onupgradeneeded=(t=>{e(t.target.result)}))})}}export default class{constructor(e){this.name=e}async init(e,a){const r=new s(this.name,this.version,e=>{Object.entries(a).forEach(async t=>{const s=t[0],a=t[1].split(",");let r=/d\++/.test(a[0]);r&&(a[0]=a[0].replace("++",""));let n=await e.createObjectStore(s,{keyPath:a[0],autoIncrement:r});a.forEach(e=>{let t=/&/i.test(e);t&&(e=e.replace("&","")),n.createIndex(e,e,{unique:t})})})});return Object.keys(a).forEach(s=>this[s]=new t(s,e,r)),this}}
